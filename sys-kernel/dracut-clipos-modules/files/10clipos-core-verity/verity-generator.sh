#!/bin/bash
# SPDX-License-Identifier: GPL-2.0-or-later
# Copyright Â© 2017 ANSSI. All rights reserved.

# Systemd generator script for the .device unit file
# Freely adapted from verity-generator from
# https://github.com/coreos/bootengine

type getarg >/dev/null 2>&1 || . /lib/dracut-lib.sh

# Systemd always invokes generators with output unit paths as arguments
unit_dirpath="${1:-}"
if [ -z "${unit_dirpath}" ]; then
    echo "Missing output unit path from this generator cmdline." >&2
    exit 255
fi

root_device="$(getarg root=)"

verity_name="$(getarg rd.verity.name=)"
verity_device="$(getarg rd.verity.device=)"
verity_roothash="$(getarg rd.verity.roothash=)"
verity_hashoffset="$(getarg rd.verity.hashoffset=)"
verity_fecoffset="$(getarg rd.verity.fecoffset=)"

# Retransform the verity device ID if it begins by a specific keyword into a
# valid path in /dev:
case "${verity_device}" in
    LABEL=*)
        verity_device="$(echo "$verity_device" | sed 's,/,\\x2f,g')"
        verity_device="/dev/disk/by-label/${verity_device#LABEL=}"
        ;;
    UUID=*)
        verity_device="${verity_device#UUID=}"
        verity_device="$(echo "$verity_device" | tr "[:upper:]" "[:lower:]")"
        verity_device="/dev/disk/by-uuid/${verity_device}"
        ;;
    PARTUUID=*)
        verity_device="${verity_device#PARTUUID=}"
        verity_device="$(echo "$verity_device" | tr "[:upper:]" "[:lower:]")"
        verity_device="/dev/disk/by-partuuid/${verity_device}"
        ;;
    PARTLABEL=*)
        verity_device="/dev/disk/by-partlabel/${verity_device#PARTLABEL=}"
        ;;
esac

# Error checking:
if [ "$(echo "${verity_device}" | head -c 1)" != "/" ]; then
    echo "rd.verity.device does not seem to be a valid device." >&2
    exit 255
fi
if [ -z "${verity_device}" ] || [ -z "${verity_name}" ] || \
    [ -z "${verity_hashoffset}" ] || [-z "${verity_roothash}" ]; then
    echo "Missing rd.verity.* argument in kernel cmdline." >&2
    exit 255
fi

# FEC is optional:
if [ -n "${verity_fecoffset}" ]; then
    veritysetup_opts_fec="--fec-offset=\"${verity_fecoffset}\""
fi

verity_device_systemd_escaped=$(systemd-escape --suffix=device --path "${verity_device}")
cat >"${unit_dirpath}/veritysetup.service" <<EOF
# Automatically generated by verity-generator

[Unit]
Description=dm-verity Setup
SourcePath=/proc/cmdline
DefaultDependencies=no
IgnoreOnIsolate=true
BindsTo=${verity_device_systemd_escaped}
After=${verity_device_systemd_escaped}

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=/bin/bash -c '/sbin/veritysetup create --hash-offset="${verity_hashoffset}" ${veritysetup_opts_fec:-} "${verity_name}" "${verity_device}" "${verity_device}" "${verity_roothash}"'

# If there's a hash mismatch during table initialization, veritysetup reports
# it on stderr but still exits 0 and the device-mapper device is still created
# but unreadable. As a consequence, the root device is impossible to use for
# the kernel.
# Therefore we manually check that the veritysetup creation has succeeded:
ExecStart=/bin/bash -c 'read off len tgt status addl <<<\$(dmsetup status "${verity_name}"); [[ "\$\${status}" == V ]]'
ExecStop=/sbin/veritysetup remove ${verity_name}
EOF

root_device_systemd_escaped=$(systemd-escape --suffix=device --path "${root_device}")

root_requires_dir="${unit_dirpath}/${root_device_systemd_escaped}.requires"
mkdir -p "${root_requires_dir}"
ln -sf "${unit_dirpath}/veritysetup.service" "${root_requires_dir}/veritysetup.service"

# vim: set ts=4 sts=4 sw=4 et:
